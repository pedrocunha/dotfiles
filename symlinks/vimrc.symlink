let g:ale_disable_lsp = 1
call plug#begin()
Plug 'fatih/vim-go', { 'do': ':GoUpdateBinaries' }
Plug 'vim-test/vim-test'
Plug 'jremmen/vim-ripgrep'
Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': './install --all' }
Plug 'junegunn/fzf.vim'
Plug 'kien/ctrlp.vim'
Plug 'flazz/vim-colorschemes'

Plug 'neovim/nvim-lspconfig'
Plug 'ms-jpq/coq_nvim', {'branch': 'coq'}
Plug 'ms-jpq/coq.artifacts', {'branch': 'artifacts'}

Plug 'rust-lang/rust.vim'
Plug 'tpope/vim-commentary'
Plug 'tpope/vim-rails'
Plug 'tpope/vim-sleuth'
Plug 'vim-scripts/closetag.vim'
Plug 'vim-scripts/kwbdi.vim'
Plug 'w0rp/ale'

"" Javascript plugins
Plug 'pangloss/vim-javascript'
Plug 'leafgarland/typescript-vim'
Plug 'MaxMEllon/vim-jsx-pretty'
Plug 'peitalin/vim-jsx-typescript'

Plug 'https://tpope.io/vim/fugitive.git'
Plug 'https://tpope.io/vim/surround.git'
call plug#end()

syntax enable
filetype plugin indent on       " load file type plugins + indentation

set nocompatible                " choose no compatibility with legacy vi
set encoding=utf-8
set showcmd                     " display incomplete commands
set nobackup                    " don't want no backup files
set noswapfile                  " no swap files
set number                      " show line numbers

"" Whitespace
set nowrap                      " don't wrap lines
set tabstop=2 shiftwidth=2      " a tab is two spaces (or set this to 4)
set expandtab                   " use spaces, not tabs (optional)
set backspace=indent,eol,start  " backspace through everything in insert mode

"" Searching
set hlsearch                    " highlight matches
set incsearch                   " incremental searching
set ignorecase                  " searches are case insensitive...
set smartcase                   " ... unless they contain at least one capital letter

"" Undoing
set undofile                    " Save undo's after file closes
set undodir=~/.vim/undo         " where to save undo histories
set undolevels=1000             " How many undos
set undoreload=10000            " number of lines to save for undo

set wildmenu
set wildmode=longest:full,full
set statusline=%<%f\ (%{&ft})\ %-4(%m%)%=%-19(%3l,%02c%03V%)
set shell=/bin/sh
set completeopt=noinsert,menuone,noselect

"" Misc
set noshowmatch " do not show parenthesis/brackets blocks

if has('termguicolors')
  let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
  let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"
  set termguicolors
endif
set background=dark
colorscheme molokai

" Delete buffers
nmap <leader>d <Plug>Kwbd

" Cycling between buffers
nnoremap <tab> :bn<CR>
nnoremap <s-tab> :bp<CR>

" Remove highlight
nnoremap h :nohl<CR>

" Close quickfix
nnoremap <leader>q :ccl<CR>

nnoremap Q :quit<CR>

nnoremap <leader>/ :Explore .<cr>
nnoremap <leader>w :w<cr>
nnoremap <leader>f :tag <cword><cr>
nnoremap <leader>gb :Git blame<cr>
nnoremap <leader>cn :e ~/Dropbox/notes/coding-notes.txt<cr>

" File & Buffer search
let g:ctrlp_cmd = 'CtrlP'
let g:ctrlp_user_command = ['.git', 'cd %s && git ls-files . -co --exclude-standard', 'find %s -type f']
let g:ctrlp_use_caching = 0
let g:fzf_tags_command = 'ctags -R -f ./.git/tags .'
set tags+=.git/tags;

nmap <leader>b :Buffers<CR>
nmap <leader>t :FZF<CR>
nmap <leader>y :Tags<CR>

" Search for word under cursor
nmap Y :Rg<CR>

let $FZF_DEFAULT_COMMAND='rg --files --hidden'

" vim-rails
nnoremap <leader>v :AV<cr>

nnoremap <leader><leader> <C-w>=

" RUBY + RAILS
" Set ruby syntax highlight
au BufRead,BufNewFile Gemfile* setfiletype ruby
au BufRead,BufNewFile *.ru setfiletype ruby
au BufRead,BufNewFile *.god setfiletype ruby

let test#strategy = "neovim"
let g:test#neovim#start_normal = 1
let test#go#gotest#options = '--mod=vendor -race'
let test#python#runner = 'pytest'
let g:test#preserve_screen = 1

nmap <silent> <leader>R :TestNearest<CR>
nmap <silent> <leader>r :TestFile<CR>

" Highlight extra whitespace
highlight ExtraWhitespace ctermbg=red guibg=red
match ExtraWhitespace /\s\+$/
autocmd BufWinEnter * match ExtraWhitespace /\s\+$/
autocmd InsertEnter * match ExtraWhitespace /\s\+\%#\@<!$/
autocmd InsertLeave * match ExtraWhitespace /\s\+$/
autocmd BufWinLeave * call clearmatches()

" Kill whitespace
function! TrimWhiteSpace()
  %s/\s\+$//e
endfunction
autocmd BufWritePre *.rb :call TrimWhiteSpace()
autocmd BufWritePre *.js :call TrimWhiteSpace()
autocmd BufWritePre *.py :call TrimWhiteSpace()

" Make those debugger statements painfully obvious
au BufEnter *.rb syn match error contained "\<binding.pry\>"
au BufEnter *.rb syn match error contained "\<debugger\>"
au BufEnter *.py syn match error contained "\<import ipdb\>"
au BufEnter *.py syn match error contained "\<ipdb.set_trace()\>"

set complete+=kspell                  " add spell check to autocompletes (invoke with C-N in i-mode)
set complete-=t                       " dont use tag and includes for autocompletes
set complete-=i                       " (gives better performance)

set iskeyword+=- " foo-bar is a whole word "

" Annoying bindings
noremap <S-Down> <nop>
noremap <S-Up> <nop>

" Ensure clipboard is not cleared after paste
xnoremap p pgvy

" +++++++++++++++++ golang settings
let g:go_doc_keywordprg_enabled = 0

" Highlight commonly used library types (`io.Reader`, etc.).
let g:go_highlight_extra_types = 1

" Highlight operators such as `:=` , `==`, `-=`, etc.
let g:go_highlight_operators = 1

" Highlight function and method declarations.
let g:go_highlight_functions = 1

" Highlight the variable names in arguments and return values in function
" declarations. Setting this implies the functionality from
" |'g:go_highlight_functions'|.
let g:go_highlight_function_arguments = 1

" Highlight struct and interface names.
let g:go_highlight_types = 1

let g:go_fmt_fail_silently = 1

nnoremap <leader>g :GoTest<cr>

let g:go_fmt_command = "goimports"
" +++++++++++++++++ golang settings

autocmd BufRead,TextChanged,TextChangedI *.go call ShowColumnIfLineTooLong(80)
autocmd BufRead,TextChanged,TextChangedI *.rb call ShowColumnIfLineTooLong(120)
autocmd BufRead,TextChanged,TextChangedI *.py call ShowColumnIfLineTooLong(120)

" Color the column marking the lengthLimit when the longest line in the file
" exceeds the lengthLimit
function! ShowColumnIfLineTooLong(lengthLimit)
  " See https://stackoverflow.com/questions/2075276/longest-line-in-vim#2982789
  let maxLineLength = max(map(getline(1,'$'), 'len(v:val)'))

  if maxLineLength > a:lengthLimit
    highlight ColorColumn ctermbg=red guibg=red
    " Draw the vertical line at the first letter that exceeds the limit
    execute "set colorcolumn=" . (a:lengthLimit + 1)
  else
    set colorcolumn=""
  endif
endfunction

" ++++++++++++++++ ALE settings
let g:ale_sign_column_always = 0
let g:ale_linters = {
      \   'python': ['flake8'],
      \}
let g:ale_fixers = {
      \'javascript': ['prettier'],
      \'typescript': ['prettier'],
      \'css': ['prettier'],
      \'python': ['black'],
      \}
let g:ale_fix_on_save = 1
let g:ale_set_signs = 1
let g:ale_completion_enabled = 1
" ++++++++++++++++ ALE settings

nmap <leader>a :call ToggleAlternateFile()<cr>
function! ToggleAlternateFile()
  let extension = expand('%:e')

  if extension == 'go'
    execute "GoAlternate"
  elseif extension == 'rb'
    execute "A"
  endif
endfunction

" ++++++++++++++++ COQ settings
let g:coq_settings = { 'auto_start': 'shut-up', 'keymap.recommended': v:false}

" let g:coq_settings = { "keymap.recommended": v:false }

" Keybindings
ino <silent><expr> <Esc>   pumvisible() ? "\<C-e><Esc>" : "\<Esc>"
ino <silent><expr> <BS>    pumvisible() ? "\<C-e><BS>"  : "\<BS>"
ino <silent><expr> <CR>    pumvisible() ? (complete_info().selected == -1 ? "\<C-e><CR>" : "\<C-y>") : "\<CR>"
ino <silent><expr> <Tab>   pumvisible() ? "\<C-n>" : "\<Tab>"
ino <silent><expr> <S-Tab> pumvisible() ? "\<C-p>" : "\<BS>"

lua << EOF
require'lspconfig'.gopls.setup{}
local opts = { noremap=true, silent=true }
local on_attach = function(client, bufnr)
  -- Enable completion triggered by <c-x><c-o>
  --vim.api.nvim_buf_set_option(bufnr, 'omnifunc', 'v:lua.vim.lsp.omnifunc')

  -- Mappings.
  -- See `:help vim.lsp.*` for documentation on any of the below functions
  --vim.api.nvim_buf_set_keymap(bufnr, 'n', 'gD', '<cmd>lua vim.lsp.buf.declaration()<CR>', opts)
  vim.api.nvim_buf_set_keymap(bufnr, 'n', 'gd', '<cmd>lua vim.lsp.buf.definition()<CR>', opts)
  vim.api.nvim_buf_set_keymap(bufnr, 'n', 'gr', '<cmd>lua vim.lsp.buf.references()<CR>', opts)
  vim.api.nvim_buf_set_keymap(bufnr, 'n', 'K', '<cmd>lua vim.lsp.buf.hover()<CR>', opts)
  --vim.api.nvim_buf_set_keymap(bufnr, 'n', 'gi', '<cmd>lua vim.lsp.buf.implementation()<CR>', opts)
  --vim.api.nvim_buf_set_keymap(bufnr, 'n', '<C-k>', '<cmd>lua vim.lsp.buf.signature_help()<CR>', opts)
  --vim.api.nvim_buf_set_keymap(bufnr, 'n', '<space>wl', '<cmd>lua print(vim.inspect(vim.lsp.buf.list_workspace_folders()))<CR>', opts)
  --vim.api.nvim_buf_set_keymap(bufnr, 'n', '<space>D', '<cmd>lua vim.lsp.buf.type_definition()<CR>', opts)
  --vim.api.nvim_buf_set_keymap(bufnr, 'n', '<space>rn', '<cmd>lua vim.lsp.buf.rename()<CR>', opts)
  --vim.api.nvim_buf_set_keymap(bufnr, 'n', '<space>ca', '<cmd>lua vim.lsp.buf.code_action()<CR>', opts)
  --vim.api.nvim_buf_set_keymap(bufnr, 'n', '<space>f', '<cmd>lua vim.lsp.buf.formatting()<CR>', opts)
end

-- Use a loop to conveniently call 'setup' on multiple servers and
-- map buffer local keybindings when the language server attaches
local servers = { 'gopls' }
for _, lsp in pairs(servers) do
  require('lspconfig')[lsp].setup {
    on_attach = on_attach,
    flags = {
      -- This will be the default in neovim 0.7+
      debounce_text_changes = 150,
    }
  }
end
EOF

" ++++++++++++++++ JS settings
autocmd BufEnter *.{js,jsx,ts,tsx} :syntax sync fromstart
autocmd BufLeave *.{js,jsx,ts,tsx} :syntax sync clear

" ++++++++++++++++ Rust settings
let g:rustfmt_autosave = 1

" ++++++++++++++++ Python settings
autocmd BufWritePre *.py execute ':Black'
